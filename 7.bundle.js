(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{44:function(e,t,s){"use strict";s.r(t);var r=s(12),n=(s(21),s(22),s(61),s(53)),i=s(3),a=s(11);class o extends r.a{static get properties(){return{rules:{type:Array},selectedRule:{type:Object,value:"",observer:"_selectedRuleChange"},contentsOrder:{type:Array,value:()=>[{id:"charactercreation",title:"Character Creation"},{id:"equipment",title:"Equipment"},{id:"playingthegame",title:"Playing the Game"},{id:"runningthegame",title:"Running the Game"},{id:"setting",title:"Setting"},{id:"unearthedarcana",title:"Unearthed Arcana"}]}}}static get observers(){return["_openRuleFromHash(hash, rules)"]}_selectedRuleChange(){if(this.selectedRule&&this.selectedRule.htmlcontent){this.dispatchEvent(new CustomEvent("title-change",{bubbles:!0,composed:!0,detail:{title:this.selectedRule.name}})),this.$.rulescontent.innerHTML=this.selectedRule.htmlcontent;let e=this.$.rulescontent.querySelectorAll("table");for(let t of e)Object(i.jqWrap)(t,'<div class="table-scroll-wrap">')}}_openRuleFromHash(){if(this.rules&&this.hash&&this.hash.length>1){let e,t=Object(i.decodeForHash)(this.hash)[0];for(let s of Object.values(this.rules)){for(let r of s)if(r.name===t){e=r;break}if(e)break}e?this.set("selectedRule",e):Object(a.a)(!0)}else this.set("selectedRule",void 0)}constructor(){super(),Object(n.a)("rules").then(e=>{const t={},s=e.compendium.rules;for(let e of s)t[e.parentlist]?t[e.parentlist].push(e):t[e.parentlist]=[e];this.set("rules",t),Object(i.initCollapseToggles)(this.shadowRoot);let r=Object(a.c)();r&&(this.hash=r)})}connectedCallback(){super.connectedCallback(),this.selectionChangeHandler=e=>{e.detail&&e.detail.selection&&(this.hash=e.detail.selection)},this.deselectionChangeHandler=()=>{this.set("selectedRule",void 0)},Object(a.e)().addEventListener("selection-change",this.selectionChangeHandler),Object(a.e)().addEventListener("selection-deselected",this.deselectionChangeHandler)}disconnectedCallback(){super.disconnectedCallback(),this.deselectionChangeHandler(),Object(a.e)().removeEventListener("selection-change",this.selectionChangeHandler),Object(a.e)().removeEventListener("selection-deselected",this.deselectionChangeHandler)}_getCategoryRules(e,t){return t?t[e]:""}_openRule(e){let t=e.target.closest(".mdc-list-item"),s=t.getAttribute("category"),r=t.getAttribute("rule"),n=Object(i.encodeForHash)(this.rules[s][r].name);Object(a.f)(n)}_exists(e){return!!e}static get template(){return r.b`
      <style include="material-styles my-styles"></style>

      <div class="rules-wrapper" hidden$="[[_exists(selectedRule)]]">
        <template is="dom-repeat" items="[[contentsOrder]]" as="category">
          <div class="collapse collapse--left-arrow">
            <div class="collapse-toggle">
              <div class="mdc-list-item rule-title mdc-theme--on-surface">
                [[category.title]]
              </div>
            </div>
            <div class="collapse-wrapper">
              <ul class$="collapse-list rules [[category.id]]">
                <template is="dom-repeat" items="[[_getCategoryRules(category.id, rules)]]" as="rule">
                  <div
                    class="mdc-list-item mdc-theme--on-surface"
                    on-click="_openRule"
                    category$="[[category.id]]"
                    rule$="[[index]]"
                  >
                    <span class="name col-xs-12">[[rule.name]]</span>
                  </div>
                </template>
              </ul>
            </div>
          </div>
        </template>
      </div>

      <div id="rulescontent" hidden$="[[!_exists(selectedRule)]]"></div>
    `}}customElements.define("dnd-rules",o);class l extends r.a{static get template(){return r.b`
      <style include="material-styles my-styles"></style>

      <dnd-rules></dnd-rules>
    `}}customElements.define("dnd-rules-view",l)},53:function(e,t,s){"use strict";s.d(t,"a",(function(){return a}));var r=s(3),n=s(4);let i={};async function a(e){if(e){if(!i.hasOwnProperty(e))switch(e){case"items":i[e]=await function(){const e=[];return e.push(o("/data/items.json")),e.push(o("/data/basicitems.json")),e.push(o("/data/magicvariants.json")),Promise.all(e).then(e=>function(e,t,s){const r={},i={};let a=e,o=t.basicitems;const l=t.itemProperty,c=t.itemType;for(let e=0;e<l.length;e++)r[l[e].abbreviation]=l[e].name?JSON.parse(JSON.stringify(l[e])):{name:l[e].entries[0].name.toLowerCase(),entries:l[e].entries};for(let e=0;e<c.length;e++)i[c[e].abbreviation]=c[e].name?JSON.parse(JSON.stringify(c[e])):{name:c[e].entries[0].name.toLowerCase(),entries:c[e].entries};let h=s;a=a.concat(o);for(let e=0;e<h.length;e++)h[e].tier=h[e].inherits.tier,h[e].rarity=h[e].inherits.rarity,h[e].source=h[e].inherits.source,h[e].page=h[e].inherits.page,!h[e].entries&&h[e].inherits.entries&&(h[e].entries=JSON.parse(JSON.stringify(h[e].inherits.entries))),h[e].requires.armor&&(h[e].armor=h[e].requires.armor);a=a.concat(h);for(let e=0;e<o.length;e++){const t=o[e];o[e].category="Basic",void 0===t.entries&&(t.entries=[]);const s=t.name.toLowerCase();for(let e=0;e<h.length;e++){const r=h[e],i=r.requires;let o=-1===s.indexOf(" (");for(const e in i)i.hasOwnProperty(e)&&t[e]!==i[e]&&(o=!1);if(r.excludes){const e=r.excludes;for(const s in e)e.hasOwnProperty(s)&&t[s]===e[s]&&(o=!1)}if(o){const e=r.inherits,i=JSON.parse(JSON.stringify(t));delete i.value,i.category="Specific Variant";for(const t in e)if(e.hasOwnProperty(t))if("namePrefix"===t)i.name=e.namePrefix+i.name;else if("nameSuffix"===t)i.name+=e.nameSuffix;else if("entries"===t)for(let t=e.entries.length-1;t>-1;t--){let r=e.entries[t];"string"==typeof r&&(i.dmgType&&(r=r.replace("{@dmgType}",n.a.dmgTypeToFull(i.dmgType))),e.genericBonus&&(r=r.replace("{@genericBonus}",e.genericBonus)),-1!==r.indexOf("{@lowerName}")&&(r=r.split("{@lowerName}").join(s))),i.entries.unshift(r)}else i[t]=e[t];a.push(i)}}}let d=(e,t)=>{const s=JSON.parse(JSON.stringify(e));return s.push(t),s};for(let e=0;e<a.length;e++){const t=a[e];if(!t.noDisplay){if("GV"===a[e].type&&(a[e].category="Generic Variant"),void 0===a[e].category&&(a[e].category="Other"),void 0===t.entries&&(a[e].entries=[]),t.type&&i[t.type])for(let s=0;s<i[t.type].entries.length;s++)a[e].entries=d(a[e].entries,i[t.type].entries[s]);if(t.property){const s=t.property.split(",");for(let t=0;t<s.length;t++)if(r[s[t]].entries)for(let n=0;n<r[s[t]].entries.length;n++)a[e].entries=d(a[e].entries,r[s[t]].entries[n])}t.armor?(t.resist&&(a[e].entries=d(a[e].entries,"You have resistance to "+t.resist+" damage while you wear this armor.")),t.armor&&t.stealth&&(a[e].entries=d(a[e].entries,"The wearer has disadvantage on Stealth (Dexterity) checks.")),"HA"===t.type&&t.strength&&(a[e].entries=d(a[e].entries,"If the wearer has a Strength score lower than "+t.strength+", their speed is reduced by 10 feet."))):t.resist&&("P"===t.type&&(a[e].entries=d(a[e].entries,"When you drink this potion, you gain resistance to "+t.resist+" damage for 1 hour.")),"RG"===t.type&&(a[e].entries=d(a[e].entries,"You have resistance to "+t.resist+" damage while wearing this ring."))),"SCF"===t.type&&("arcane"===t.scfType&&(a[e].entries=d(a[e].entries,"An arcane focus is a special item designed to channel the power of arcane spells. A sorcerer, warlock, or wizard can use such an item as a spellcasting focus, using it in place of any material component which does not list a cost.")),"druid"===t.scfType&&(a[e].entries=d(a[e].entries,"A druid can use such a druidic focus as a spellcasting focus, using it in place of any material component that does not have a cost.")),"holy"===t.scfType&&(a[e].entries=d(a[e].entries,"A holy symbol is a representation of a god or pantheon."),a[e].entries=d(a[e].entries,"A cleric or paladin can use a holy symbol as a spellcasting focus, using it in place of any material components which do not list a cost. To use the symbol in this way, the caster must hold it in hand, wear it visibly, or bear it on a shield.")))}}for(let e=0;e<a.length;e++){const t=a[e];if(!t.noDisplay){if("GV"===a[e].type&&(a[e].category="Generic Variant"),void 0===a[e].category&&(a[e].category="Other"),void 0===t.entries&&(a[e].entries=[]),t.type&&i[t.type])for(let s=0;s<i[t.type].entries.length;s++)a[e].entries=d(a[e].entries,i[t.type].entries[s]);if(t.property){const s=t.property.split(",");for(let t=0;t<s.length;t++)if(r[s[t]].entries)for(let n=0;n<r[s[t]].entries.length;n++)a[e].entries=d(a[e].entries,r[s[t]].entries[n])}t.armor?(t.resist&&(a[e].entries=d(a[e].entries,"You have resistance to "+t.resist+" damage while you wear this armor.")),t.armor&&t.stealth&&(a[e].entries=d(a[e].entries,"The wearer has disadvantage on Stealth (Dexterity) checks.")),"HA"===t.type&&t.strength&&(a[e].entries=d(a[e].entries,"If the wearer has a Strength score lower than "+t.strength+", their speed is reduced by 10 feet."))):t.resist&&("P"===t.type&&(a[e].entries=d(a[e].entries,"When you drink this potion, you gain resistance to "+t.resist+" damage for 1 hour.")),"RG"===t.type&&(a[e].entries=d(a[e].entries,"You have resistance to "+t.resist+" damage while wearing this ring."))),"SCF"===t.type&&("arcane"===t.scfType&&(a[e].entries=d(a[e].entries,"An arcane focus is a special item designed to channel the power of arcane spells. A sorcerer, warlock, or wizard can use such an item as a spellcasting focus, using it in place of any material component which does not list a cost.")),"druid"===t.scfType&&(a[e].entries=d(a[e].entries,"A druid can use such a druidic focus as a spellcasting focus, using it in place of any material component that does not have a cost.")),"holy"===t.scfType&&(a[e].entries=d(a[e].entries,"A holy symbol is a representation of a god or pantheon."),a[e].entries=d(a[e].entries,"A cleric or paladin can use a holy symbol as a spellcasting focus, using it in place of any material components which do not list a cost. To use the symbol in this way, the caster must hold it in hand, wear it visibly, or bear it on a shield.")))}}return a}(e[0],e[1],e[2]))}();break;case"bestiary":i[e]=await function(){const e=[];return e.push(o("/data/bestiary.json")),e.push(o("/data/legendarygroups.json")),Promise.all(e).then(e=>function(e,t){const s={};for(let e of t)s[e.name]={lairActions:e.lairActions,regionalEffects:e.regionalEffects};for(let t of e)if(t.legendaryGroup){const e=t.legendaryGroup;if(e){const n=s[e];n.lairActions&&(t.lairaction=Object(r.cloneDeep)(n.lairActions)),n.regionalEffects&&(t.regionaleffect=Object(r.cloneDeep)(n.regionalEffects))}}return e}(e[0],e[1]))}();break;case"spells":case"classes":i[e]=await async function(e){const t=await o(`/data/${e}/index.json`);if(t.index){let s=[];for(let r of Object.values(t.index))s.push(o(`/data/${e}/${r}`));return Promise.all(s).then(e=>{let t=[];for(let s of e)t=t.concat(s);return t})}return console.error("Model index data not found from model JSON"),[]}(e);break;default:i[e]=await async function(e){const t=await o(`/data/${e}.json`);return Array.isArray(t)?t:(console.error("Array data not found from model JSON"),[])}(e)}return i[e]}return console.error("Missing modelID"),[]}function o(e){return fetch(e).then(e=>{if(!e.ok)throw new Error("Network response was not ok");return e.json()})}}}]);
//# sourceMappingURL=7.bundle.js.map